<app-contents-scrollspy>
  <h1>Model-View-ViewModel (MVVM)</h1>
  <p class="lead">
    Learn how to create Angular applications using popular architectural pattern
    - MVVM.
  </p>

  <!-- why-mvvm -->
  <section id="why-mvvm" aria-label="Why MVVM?">
    <h2>Why MVVM?</h2>
    <div>
      <p>
        MVVM is a well-known architectural pattern, mostly used in .NET or
        Angular application development, but can also be found in other
        frameworks and libraries.
      </p>
      <p>
        Angular itself already uses an MVVM-like approach where View can be
        referred to component's template, and ViewModel to component's
        code-behind class. However, including a presentational logic in
        code-behind code of the component is usually not a good idea, because
        very often it is loosely coupled with a component, and either duplicates
        a code or does not provide a good separation of concerns.
      </p>
      <p>Therefore, the goals of following architectural design are:</p>
      <ul class="fw-bolder">
        <li>Writing as little and as native code as possible</li>
        <li>Easy to learn</li>
        <li>Better separation of concerns and better testability</li>
        <li>Scalability</li>
        <li>Inheritance</li>
      </ul>
    </div>
  </section>

  <!-- mvvm-layers -->
  <section id="mvvm-layers" aria-label="MVVM Layers">
    <h2>Layers of MVVM</h2>
    <div>
      <div class="d-flex flex-column align-items-center">
        <div class="h3 w-100">
          <span
            class="badge bg-warning d-flex flex-column justify-content-center w-100"
            style="height: 10rem"
            >Model</span
          >
        </div>
        <p class="align-self-start">
          The Model is usually referred to data access layer, however, it can
          also contain a business logic of the application.
        </p>
        <ul
          class="list-unstyled d-flex flex-column justify-content-center mt-4 mb-5 p-3 text-center border rounded w-100"
        >
          <li>Send data</li>
          <li>Receive data</li>
        </ul>
        <div class="h3 w-100">
          <span
            class="badge bg-success d-flex flex-column justify-content-center w-100"
            style="height: 10rem"
            >ViewModel</span
          >
        </div>
        <p class="align-self-start">
          The ViewModel is a layer of presentational logic and keeps a state of
          the View and operations that can be performed within a View. ViewModel
          is also responsible for notifying a View about its state changes,
          validating user inputs or communication with the Model layer.
        </p>
        <ul
          class="list-unstyled d-flex flex-column justify-content-center mt-4 mb-5 p-3 text-center border rounded w-100"
        >
          <li>2-Way Bindings</li>
          <li>Commands</li>
          <li>Value Changes</li>
        </ul>
        <div class="h3 w-100">
          <span
            class="badge bg-primary d-flex flex-column justify-content-center w-100"
            style="height: 10rem"
            >View</span
          >
        </div>
        <p class="align-self-start">
          The View can be referred to a display component, which consumes
          ViewModel in order to bind the state of its properties or action
          triggers. Using ReactiveForms we can also perform so-called two-way
          binding and synchronize user input back to the ViewModel. The View is
          updated when a state of ViewModel has changed.
        </p>
      </div>
    </div>
  </section>

  <!-- folder-structure -->
  <section id="folder-structure" aria-label="Folder structure">
    <h2>Folder structure</h2>
    <div>
      <p>
        In order to separate concers following folders are contained in each
        feature module of the Angular application.
      </p>
      <ul>
        <li><small>app</small></li>
        <ul>
          <li><small>sample</small></li>
          <ul class="bg-light">
            <li>
              <b>components</b>&nbsp;<i
                >(...dumb components with only inputs and outputs goes here)</i
              >
            </li>
            <li>
              <b>models</b>&nbsp;<i
                >(...interfaces, enums, or other types goes here)</i
              >
            </li>
            <li><b>services</b></li>
            <ul>
              <li>sample.service.ts</li>
            </ul>
            <li><b>view-models</b></li>
            <ul>
              <li>sample-view-model.ts</li>
            </ul>
            <li><b>views</b></li>
            <ul>
              <li>sample-view</li>
              <ul>
                <li>sample-view.component.html</li>
                <li>sample-view.component.ts</li>
              </ul>
            </ul>
            <li><small>sample-routing.module.ts</small></li>
            <li><small>sample.module.ts</small></li>
          </ul>
          <li><small>app-routing.module.ts</small></li>
          <li><small>app.component.html</small></li>
          <li><small>app.component.ts</small></li>
          <li><small>app.module.ts</small></li>
        </ul>
      </ul>
      <p>
        If you want, you can also further organize the services, view-models and
        views folders into sub-folders.
      </p>
      <ul>
        <li><b>view-models</b></li>
        <ul>
          <li>employee</li>
          <ul>
            <li>employee-list-view-model.ts</li>
            <li>employee-detail-view-model.ts</li>
          </ul>
          <li>customer</li>
          <ul>
            <li>customer-list-view-model.ts</li>
            <li>customer-detail-view-model.ts</li>
          </ul>
        </ul>
      </ul>
    </div>
  </section>

  <!-- creating-viewmodel -->
  <section id="creating-viewmodel" aria-label="Creating ViewModel">
    <h2>Creating ViewModel</h2>
    <div>
      <p>
        Once we are settled on folder structure, we can add our first ViewModel
        by creating a class suffixed with ViewModel and extending ViewModel
        class from NgToolkit. Each ViewModel has to call the init() function in
        order to emit changes of its Observables or FormControls.
      </p>
      <app-code-highlighter
        code="
import { Injectable } from '@angular/core';
import { ViewModel } from 'ng-toolkit-lib';

@Injectable()
export class SamplesViewModel extends ViewModel {
  constructor() {
    super();
    this.init();
  }
}"
      ></app-code-highlighter>
      <p>
        You can also notice that a ViewModel is treated as injectable service.
        This will help us to either mock it during testing or reuse the
        functionality at multiple places without depending on a View.
      </p>
      <p>
        Once we have created our first ViewModel, let's add a ReactiveForm and
        Observable. Their state will be further used in a ViewModel methods or
        using bindings in a View.
      </p>
      <app-code-highlighter
        code="
@Injectable()
export class SamplesViewModel extends ViewModel {
  form = new FormGroup({
    text: new FormControl('FormControl Text'),
    bool: new FormControl(true),
    samples: new FormArray([new FormControl(), new FormControl()]),
  });

  text$ = new BehaviorSubject<string>('Observable Text');

  ...
}"
      ></app-code-highlighter>
      <p>
        Last, but not least, let's add some methods to either add or remove an
        item of form.samples array.
      </p>
      <app-code-highlighter
        code="
@Injectable()
export class SamplesViewModel extends ViewModel {
  get formSamples(): FormArray {
    return this.form.get('samples') as FormArray;
  }

  ...

  addSample(): void {
    this.formSamples.push(new FormControl());
  }

  removeSample(index: number): void {
    this.formSamples.removeAt(index);
  }
}"
      ></app-code-highlighter>
    </div>
  </section>

  <!-- creating-view -->
  <section id="creating-view" aria-label="Creating View">
    <h2>Creating View</h2>
    <div>
      <p>
        After we have created a ViewModel, we also need a display component
        called View. In component's code-behind file we will then define a
        provider for a ViewModel, so each component has its own instance (if you
        rather wish to share a ViewModel between multiple components, define a
        provider in one of the parent Views or parent NgModule).
      </p>
      <app-code-highlighter
        code="
@Component({
  selector: 'app-samples-view',
  templateUrl: './samples-view.component.html',
  styleUrls: ['./samples-view.component.scss'],
  providers: [SamplesViewModel],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SamplesViewComponent {
  constructor(public vm: SamplesViewModel) { }
}"
      ></app-code-highlighter>
      <p>
        As you can notice, our ViewModel type will be then injected to public
        property called vm upon component's creation.
      </p>
      <p>
        In HTML template we then subscribe once using async pipe to all changes
        on a ViewModel observables.
      </p>
      <app-code-highlighter
        code="
<ng-container *ngIf=''vm.changes$ | async''>
  ...
</ng-container>''"
      ></app-code-highlighter>
      <p>
        and bind a Observable and FormControl instances, as well as their
        values, or last but not least, the methods defined on the ViewModel.
      </p>
      <app-code-highlighter
        code="
<!-- FormControl binding -->
<input type=''text'' [formControl]=''vm.form.get('text')'' />

<!-- FormControl value binding -->
[[ form.get('text').value ]]

<!-- Observable value binding -->
[[ text$.value ]]

<!-- Observable value/change binding -->
<input type=''text'' [value]=''vm.text$.value'' (change)=''vm.text$.next($event.target.value)'' />

<!-- Method binding -->
<button class=''btn btn-success'' (click)=''vm.addSample()''>+ Add Sample</button>"
      ></app-code-highlighter>
    </div>
  </section>
</app-contents-scrollspy>
